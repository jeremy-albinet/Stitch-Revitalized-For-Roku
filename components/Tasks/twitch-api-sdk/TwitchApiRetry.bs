' TwitchApiRetry.bs - Retry logic for API calls with exponential backoff

function TwitchGraphQLRequestWithRetry(data, maxRetries = 3) as object
    retryCount = 0
    baseDelay = 1000 ' 1 second base delay
    maxDelay = 30000 ' 30 seconds max delay

    while retryCount < maxRetries
        response = TwitchGraphQLRequest(data)

        if response <> invalid
            ' Check for GraphQL errors
            if response.errors = invalid or response.errors.count() = 0
                return response
            end if

            ' Check if error is retryable
            if not isRetryableError(response.errors)
                return response
            end if
        end if

        retryCount = retryCount + 1

        if retryCount < maxRetries
            ' Calculate exponential backoff with jitter
            delay = calculateBackoff(baseDelay, retryCount, maxDelay)
            ' ? "[TwitchApiRetry] Request failed, retrying in "; delay; "ms (attempt "; retryCount; " of "; maxRetries; ")"
            sleep(delay)
        end if
    end while

    ' ? "[TwitchApiRetry] Max retries reached, request failed"
    return invalid
end function

function isRetryableError(errors as object) as boolean
    if errors = invalid or errors.count() = 0
        return true ' Network error, should retry
    end if

    for each error in errors
        if error.message <> invalid
            errorMsg = LCase(error.message)

            ' Don't retry authentication errors
            if errorMsg.InStr("unauthorized") > -1 or errorMsg.InStr("forbidden") > -1
                return false
            end if

            ' Don't retry invalid request errors
            if errorMsg.InStr("invalid") > -1 or errorMsg.InStr("bad request") > -1
                return false
            end if

            ' Retry timeout and network errors
            if errorMsg.InStr("timeout") > -1 or errorMsg.InStr("network") > -1
                return true
            end if

            ' Retry rate limit errors
            if errorMsg.InStr("rate") > -1 or errorMsg.InStr("limit") > -1
                return true
            end if

            ' Retry server errors
            if errorMsg.InStr("server") > -1 or errorMsg.InStr("503") > -1 or errorMsg.InStr("502") > -1
                return true
            end if
        end if
    end for

    ' Default to retry for unknown errors
    return true
end function

function calculateBackoff(baseDelay as integer, retryCount as integer, maxDelay as integer) as integer
    ' Exponential backoff: delay = baseDelay * 2^(retryCount - 1)
    delay = baseDelay * (2 ^ (retryCount - 1))

    ' Add jitter (0-25% of delay)
    jitter = Rnd(delay * 0.25)
    delay = delay + jitter

    ' Cap at maxDelay
    if delay > maxDelay
        delay = maxDelay
    end if

    return delay
end function

function HttpRequestWithRetry(params as object, maxRetries = 3) as dynamic
    retryCount = 0
    baseDelay = 1000
    maxDelay = 30000

    while retryCount < maxRetries
        req = HttpRequest(params)
        response = req.send()

        if response <> invalid
            ' Check HTTP status code if available
            responseCode = req.getResponseCode()
            if responseCode >= 200 and responseCode < 300
                return response
            else if not isRetryableHttpCode(responseCode)
                return response
            end if
        end if

        retryCount = retryCount + 1

        if retryCount < maxRetries
            delay = calculateBackoff(baseDelay, retryCount, maxDelay)
            ' ? "[HttpRequestWithRetry] Request failed with code "; responseCode; ", retrying in "; delay; "ms"
            sleep(delay)
        end if
    end while

    return invalid
end function

function isRetryableHttpCode(code as integer) as boolean
    ' Retry on server errors (5xx)
    if code >= 500 and code < 600
        return true
    end if

    ' Retry on specific client errors
    if code = 408 ' Request Timeout
        return true
    else if code = 429 ' Too Many Requests
        return true
    else if code = 0 ' Network error
        return true
    end if

    ' Don't retry on other client errors (4xx)
    return false
end function

' Connection pooling manager
function getConnectionPool() as object
    if m.global.connectionPool = invalid
        m.global.connectionPool = {
            connections: [],
            maxConnections: 5,
            connectionTimeout: 30000
        }
    end if
    return m.global.connectionPool
end function

function getPooledConnection(url as string) as object
    pool = getConnectionPool()
    now = CreateObject("roDateTime").AsSeconds() * 1000

    ' Clean up expired connections
    validConnections = []
    for each conn in pool.connections
        if now - conn.lastUsed < pool.connectionTimeout
            validConnections.push(conn)
        end if
    end for
    pool.connections = validConnections

    ' Find existing connection for URL
    for each conn in pool.connections
        if conn.url = url and conn.available
            conn.available = false
            conn.lastUsed = now
            return conn.httpAgent
        end if
    end for

    ' Create new connection if under limit
    if pool.connections.count() < pool.maxConnections
        httpAgent = CreateObject("roHttpAgent")
        httpAgent.setCertificatesFile("common:/certs/ca-bundle.crt")
        httpAgent.InitClientCertificates()
        httpAgent.enableCookies()

        newConn = {
            url: url,
            httpAgent: httpAgent,
            available: false,
            lastUsed: now
        }
        pool.connections.push(newConn)

        return httpAgent
    end if

    ' Reuse oldest connection
    if pool.connections.count() > 0
        oldestConn = pool.connections[0]
        oldestConn.url = url
        oldestConn.available = false
        oldestConn.lastUsed = now
        return oldestConn.httpAgent
    end if

    ' Fallback: create new agent
    httpAgent = CreateObject("roHttpAgent")
    httpAgent.setCertificatesFile("common:/certs/ca-bundle.crt")
    httpAgent.InitClientCertificates()
    httpAgent.enableCookies()
    return httpAgent
end function

sub releasePooledConnection(url as string)
    pool = getConnectionPool()
    for each conn in pool.connections
        if conn.url = url
            conn.available = true
            exit for
        end if
    end for
end sub
